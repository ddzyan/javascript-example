参考文章：

- https://juejin.im/post/5b827cbbe51d4538c021f2da
- https://github.com/mcollina/autocannon

文章你所能了解的内容：

1. 压力测试能做什么
2. 怎么进行压力测试
3. 如何分析压力测试结果

## 简介

在系统上线之前，我们非常有必要了解系统最多能支持的并发数是多少，并且了解在压力测试情况下的资源占用情况，针对性优化代码，提升系统性能。

负载测试指标：

- TPS：每秒能够处理的请求数量

这里我使用的压力测试是 autocannon ，其他的工具有：loadTest,ab,locust 等

### 安装

```
npm i -g autocannon
```

#### 参数

- -c:并发的客户端数量，默认为 10
- -d:持续测试时间，默认 10 秒
- -a:总共发送的请求数量
- -p:每个并发每秒发送的请求数量，默认 1 个
- -b:请求的报文
- -m:请求的方法，默认 GET

### 操作

#### demo1

cpu-server.js 里面是一个高负载的 CPU 运算，而这样的运算会导致主线程卡死，无法接收其他请求，造成 TPS 减少

```shell
node ./cpu-server.js

# 并发数量10，持续10秒，每个并发每次发送1个请求
autocannon localhost:3000

Running 10s test @ http://localhost:3000
10 connections

┌─────────┬────────┬────────┬────────┬────────┬───────────┬──────────┬───────────┐
│ Stat    │ 2.5%   │ 50%    │ 97.5%  │ 99%    │ Avg       │ Stdev    │ Max       │
├─────────┼────────┼────────┼────────┼────────┼───────────┼──────────┼───────────┤
│ Latency │ 110 ms │ 122 ms │ 178 ms │ 206 ms │ 127.41 ms │ 18.57 ms │ 239.36 ms │
└─────────┴────────┴────────┴────────┴────────┴───────────┴──────────┴───────────┘
┌───────────┬─────────┬─────────┬─────────┬─────────┬─────────┬───────┬─────────┐
│ Stat      │ 1%      │ 2.5%    │ 50%     │ 97.5%   │ Avg     │ Stdev │ Min     │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────┼─────────┤
│ Req/Sec   │ 65      │ 65      │ 78      │ 85      │ 77.6    │ 5.72  │ 65      │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────┼─────────┤
│ Bytes/Sec │ 6.83 kB │ 6.83 kB │ 8.19 kB │ 8.93 kB │ 8.15 kB │ 600 B │ 6.83 kB │
└───────────┴─────────┴─────────┴─────────┴─────────┴─────────┴───────┴─────────┘

Req/Bytes counts sampled once per second.

776 requests in 10.07s, 81.5 kB read
```

结果：

- 平均每个请求消耗：127.41 ms
- 平均每秒处理的请求数量：77.6 个

#### demo2

io-server 内没有任务处理任务，可以观察 nodejs 性能瓶颈

```shell
node ./io-server.js

# 并发数量10，持续10秒，每个并发每次发送1个请求
autocannon localhost:3000

Running 10s test @ http://localhost:3000
10 connections

┌─────────┬──────┬──────┬───────┬──────┬─────────┬─────────┬──────────┐
│ Stat    │ 2.5% │ 50%  │ 97.5% │ 99%  │ Avg     │ Stdev   │ Max      │
├─────────┼──────┼──────┼───────┼──────┼─────────┼─────────┼──────────┤
│ Latency │ 0 ms │ 0 ms │ 1 ms  │ 1 ms │ 0.04 ms │ 0.28 ms │ 20.93 ms │
└─────────┴──────┴──────┴───────┴──────┴─────────┴─────────┴──────────┘
┌───────────┬─────────┬─────────┬────────┬─────────┬─────────┬────────┬─────────┐
│ Stat      │ 1%      │ 2.5%    │ 50%    │ 97.5%   │ Avg     │ Stdev  │ Min     │
├───────────┼─────────┼─────────┼────────┼─────────┼─────────┼────────┼─────────┤
│ Req/Sec   │ 13887   │ 13887   │ 20015  │ 21599   │ 19266   │ 2370   │ 13881   │
├───────────┼─────────┼─────────┼────────┼─────────┼─────────┼────────┼─────────┤
│ Bytes/Sec │ 1.53 MB │ 1.53 MB │ 2.2 MB │ 2.38 MB │ 2.12 MB │ 261 kB │ 1.53 MB │
└───────────┴─────────┴─────────┴────────┴─────────┴─────────┴────────┴─────────┘

Req/Bytes counts sampled once per second.

193k requests in 10.1s, 21.2 MB read
```

结果：

- 平均每个请求消耗：0.04 ms
- 平均每秒处理的请求数量： 21599 个

从结果也可以看出，nodejs 非常不适合进行一些高 CPU 的运算。
